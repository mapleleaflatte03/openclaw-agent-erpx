name: deploy-staging

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      overlay:
        description: "Kustomize overlay to deploy"
        required: false
        default: "staging"
        type: choice
        options:
          - staging
          - staging-single
          - staging-6nodes
      namespace:
        description: "Target namespace (optional override)"
        required: false
        default: ""

permissions:
  contents: read
  packages: write

concurrency:
  group: accounting-agent-staging
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install Python deps
        run: |
          python -m pip install -U pip
          python -m pip install -e '.[dev,ui,graphs,ray]'

      - name: Gate (lint/test/openapi)
        run: |
          python -m compileall -q src scripts
          ruff check .
          pytest
          python scripts/export_openapi.py
          git diff --exit-code openapi/

      - uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Build & push (agent-service)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: services/agent-service/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/agent-service:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/agent-service:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push (agent-worker)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: services/agent-worker/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/agent-worker:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/agent-worker:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push (agent-scheduler)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: services/agent-scheduler/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/agent-scheduler:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/agent-scheduler:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push (erpx-mock-api)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: services/erpx-mock-api/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/erpx-mock-api:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/erpx-mock-api:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push (ui)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: services/ui/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/ui:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/accounting-agent-layer/ui:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: Setup kustomize
        run: |
          set -euo pipefail
          curl -sL "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.7.1/kustomize_v5.7.1_linux_amd64.tar.gz" \
            | tar xz -C /usr/local/bin
          kustomize version

      - name: Configure kubeconfig
        env:
          KUBECONFIG_B64: ${{ secrets.STAGING_KUBECONFIG_B64 }}
        run: |
          set -euo pipefail
          if [ -z "${KUBECONFIG_B64:-}" ]; then
            echo "Missing secret: STAGING_KUBECONFIG_B64" >&2
            exit 1
          fi
          echo "${KUBECONFIG_B64}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> "$GITHUB_ENV"

      - name: Create/Update image pull secret (ghcr-pull)
        env:
          NS: ${{ github.event.inputs.namespace }}
          GHCR_USERNAME: ${{ github.actor }}
          GHCR_PASSWORD: ${{ github.token }}
          OVERLAY: ${{ github.event.inputs.overlay || 'staging' }}
        run: |
          set -euo pipefail
          NS="${NS:-accounting-agent-staging}"
          OVERLAY_DIR="deploy/k8s/overlays/${OVERLAY}"

          # Namespace must exist before creating secrets.
          kubectl apply -f "${OVERLAY_DIR}/namespace.yaml"

          # GHCR packages are private by default; provide a pull secret to the cluster.
          kubectl -n "$NS" create secret docker-registry ghcr-pull \
            --docker-server=ghcr.io \
            --docker-username="$GHCR_USERNAME" \
            --docker-password="$GHCR_PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Guard NO-ROTATE (refuse credential rotation)
        env:
          NS: ${{ github.event.inputs.namespace }}
          POSTGRES_PASSWORD: ${{ secrets.STAGING_POSTGRES_PASSWORD }}
          AGENT_API_KEY: ${{ secrets.STAGING_AGENT_API_KEY }}
          MINIO_ACCESS_KEY: ${{ secrets.STAGING_MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY: ${{ secrets.STAGING_MINIO_SECRET_KEY }}
        run: |
          set -euo pipefail
          NS="${NS:-accounting-agent-staging}"

          # If secret doesn't exist yet, allow creation
          if ! kubectl -n "$NS" get secret agent-secrets >/dev/null 2>&1; then
            echo "Secret agent-secrets does not exist yet — will be created."
            exit 0
          fi

          echo "Secret agent-secrets exists — verifying no credential rotation…"

          check_key() {
            local key="$1" expected_val="$2" ch eh
            ch=$(kubectl -n "$NS" get secret agent-secrets \
                 -o jsonpath="{.data.${key}}" | base64 -d | sha256sum | awk '{print $1}')
            eh=$(printf '%s' "$expected_val" | sha256sum | awk '{print $1}')
            if [ "$ch" != "$eh" ]; then
              echo "::error::NO-ROTATE VIOLATION: ${key} hash on cluster (${ch:0:12}…) != GitHub secret (${eh:0:12}…)"
              return 1
            fi
            echo "  ✓ ${key} hash matches (${ch:0:12}…)"
            return 0
          }

          MISMATCH=0
          check_key POSTGRES_PASSWORD "$POSTGRES_PASSWORD" || MISMATCH=1
          check_key AGENT_API_KEY     "$AGENT_API_KEY"     || MISMATCH=1
          check_key MINIO_ACCESS_KEY  "$MINIO_ACCESS_KEY"  || MISMATCH=1
          check_key MINIO_SECRET_KEY  "$MINIO_SECRET_KEY"  || MISMATCH=1

          if [ "$MISMATCH" -ne 0 ]; then
            echo "::error::Refusing to rotate credentials in deploy-staging; secrets mismatch between GitHub and cluster."
            echo "::error::Sync GitHub Secrets to match cluster values, or update cluster manually first."
            exit 1
          fi

          echo "All credential hashes match — proceeding with secret apply."

      - name: Create/Update k8s secrets (agent-secrets)
        env:
          NS: ${{ github.event.inputs.namespace }}
          OVERLAY: ${{ github.event.inputs.overlay || 'staging' }}
          POSTGRES_PASSWORD: ${{ secrets.STAGING_POSTGRES_PASSWORD }}
          ERPX_TOKEN: ${{ secrets.STAGING_ERPX_TOKEN }}
          AGENT_API_KEY: ${{ secrets.STAGING_AGENT_API_KEY }}
          MINIO_ACCESS_KEY: ${{ secrets.STAGING_MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY: ${{ secrets.STAGING_MINIO_SECRET_KEY }}
          SMTP_HOST: ${{ secrets.STAGING_SMTP_HOST }}
          SMTP_USER: ${{ secrets.STAGING_SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.STAGING_SMTP_PASSWORD }}
        run: |
          set -euo pipefail
          NS="${NS:-accounting-agent-staging}"

          if [ -z "${POSTGRES_PASSWORD:-}" ]; then echo "Missing secret: STAGING_POSTGRES_PASSWORD" >&2; exit 1; fi
          if [ -z "${AGENT_API_KEY:-}" ]; then echo "Missing secret: STAGING_AGENT_API_KEY" >&2; exit 1; fi
          if [ -z "${MINIO_ACCESS_KEY:-}" ]; then echo "Missing secret: STAGING_MINIO_ACCESS_KEY" >&2; exit 1; fi
          if [ -z "${MINIO_SECRET_KEY:-}" ]; then echo "Missing secret: STAGING_MINIO_SECRET_KEY" >&2; exit 1; fi

          kubectl apply -f "deploy/k8s/overlays/${OVERLAY}/namespace.yaml"

          kubectl -n "$NS" create secret generic agent-secrets \
            --from-literal=POSTGRES_DB="agent" \
            --from-literal=POSTGRES_USER="agent" \
            --from-literal=POSTGRES_PASSWORD="$POSTGRES_PASSWORD" \
            --from-literal=AGENT_DB_DSN="postgresql+psycopg://agent:${POSTGRES_PASSWORD}@postgres:5432/agent" \
            --from-literal=ERPX_TOKEN="${ERPX_TOKEN:-}" \
            --from-literal=AGENT_API_KEY="$AGENT_API_KEY" \
            --from-literal=MINIO_ACCESS_KEY="$MINIO_ACCESS_KEY" \
            --from-literal=MINIO_SECRET_KEY="$MINIO_SECRET_KEY" \
            --from-literal=MINIO_ROOT_USER="$MINIO_ACCESS_KEY" \
            --from-literal=MINIO_ROOT_PASSWORD="$MINIO_SECRET_KEY" \
            --from-literal=SMTP_HOST="${SMTP_HOST:-}" \
            --from-literal=SMTP_PORT="587" \
            --from-literal=SMTP_USER="${SMTP_USER:-}" \
            --from-literal=SMTP_PASSWORD="${SMTP_PASSWORD:-}" \
            --from-literal=SMTP_FROM="accounting@example.local" \
            --from-literal=SMTP_TLS="true" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update k8s secrets (agent-llm)
        env:
          NS: ${{ github.event.inputs.namespace }}
          DO_AGENT_BASE_URL: ${{ secrets.STAGING_DO_AGENT_BASE_URL }}
          DO_AGENT_API_KEY: ${{ secrets.STAGING_DO_AGENT_API_KEY }}
          DO_AGENT_MODEL: ${{ secrets.STAGING_DO_AGENT_MODEL }}
          OCR_CLOUD_BASE_URL: ${{ secrets.STAGING_OCR_CLOUD_BASE_URL }}
          OCR_CLOUD_API_KEY: ${{ secrets.STAGING_OCR_CLOUD_API_KEY }}
          OCR_CLOUD_MODEL: ${{ secrets.STAGING_OCR_CLOUD_MODEL }}
          OCR_CLOUD_TIMEOUT_SECONDS: ${{ secrets.STAGING_OCR_CLOUD_TIMEOUT_SECONDS }}
        run: |
          set -euo pipefail
          NS="${NS:-accounting-agent-staging}"

          DO_AGENT_BASE_URL="${DO_AGENT_BASE_URL:-}"
          DO_AGENT_API_KEY="${DO_AGENT_API_KEY:-}"
          DO_AGENT_MODEL="${DO_AGENT_MODEL:-gpt-4.1-mini}"
          OCR_CLOUD_BASE_URL="${OCR_CLOUD_BASE_URL:-https://api.openai.com}"
          OCR_CLOUD_API_KEY="${OCR_CLOUD_API_KEY:-$DO_AGENT_API_KEY}"
          OCR_CLOUD_MODEL="${OCR_CLOUD_MODEL:-gpt-4.1-mini}"
          OCR_CLOUD_TIMEOUT_SECONDS="${OCR_CLOUD_TIMEOUT_SECONDS:-20}"

          if [ -z "${DO_AGENT_BASE_URL}" ] || [ -z "${DO_AGENT_API_KEY}" ]; then
            echo "Missing STAGING_DO_AGENT_BASE_URL or STAGING_DO_AGENT_API_KEY" >&2
            exit 1
          fi
          if [ -z "${OCR_CLOUD_API_KEY}" ]; then
            echo "Missing STAGING_OCR_CLOUD_API_KEY (or fallback STAGING_DO_AGENT_API_KEY)" >&2
            exit 1
          fi

          kubectl -n "$NS" create secret generic agent-llm \
            --from-literal=DO_AGENT_BASE_URL="${DO_AGENT_BASE_URL}" \
            --from-literal=DO_AGENT_API_KEY="${DO_AGENT_API_KEY}" \
            --from-literal=DO_AGENT_MODEL="${DO_AGENT_MODEL}" \
            --from-literal=OCR_CLOUD_BASE_URL="${OCR_CLOUD_BASE_URL}" \
            --from-literal=OCR_CLOUD_API_KEY="${OCR_CLOUD_API_KEY}" \
            --from-literal=OCR_CLOUD_MODEL="${OCR_CLOUD_MODEL}" \
            --from-literal=OCR_CLOUD_TIMEOUT_SECONDS="${OCR_CLOUD_TIMEOUT_SECONDS}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Restart statefulsets (pick up new secrets)
        env:
          NS: ${{ github.event.inputs.namespace }}
        run: |
          set -euxo pipefail
          NS="${NS:-accounting-agent-staging}"
          kubectl -n "$NS" rollout restart statefulset/postgres statefulset/redis statefulset/minio
          kubectl -n "$NS" rollout status statefulset/postgres --timeout=300s
          kubectl -n "$NS" rollout status statefulset/redis   --timeout=300s
          kubectl -n "$NS" rollout status statefulset/minio    --timeout=300s

      - name: Patch image tags (sed)
        env:
          OVERLAY: ${{ github.event.inputs.overlay || 'staging' }}
        run: |
          set -euxo pipefail
          OVERLAY_DIR="deploy/k8s/overlays/${OVERLAY:-staging}"
          echo "SHA=${GITHUB_SHA}"
          sed -i "s|newTag: staging-latest|newTag: ${GITHUB_SHA}|g" "$OVERLAY_DIR/kustomization.yaml"
          cat "$OVERLAY_DIR/kustomization.yaml"

      - name: Delete old k8s jobs
        env:
          NS: ${{ github.event.inputs.namespace }}
        run: |
          set -euxo pipefail
          NS="${NS:-accounting-agent-staging}"
          kubectl -n "$NS" delete job minio-init --ignore-not-found
          kubectl -n "$NS" delete job agent-migrate --ignore-not-found

      - name: Apply kustomize manifests
        env:
          NS: ${{ github.event.inputs.namespace }}
          OVERLAY: ${{ github.event.inputs.overlay || 'staging' }}
        run: |
          set -euxo pipefail
          OVERLAY_DIR="deploy/k8s/overlays/${OVERLAY:-staging}"
          kustomize build "$OVERLAY_DIR" | kubectl apply -f -

      - name: Wait for jobs
        env:
          NS: ${{ github.event.inputs.namespace }}
        run: |
          set -euxo pipefail
          NS="${NS:-accounting-agent-staging}"
          kubectl -n "$NS" wait --for=condition=complete job/minio-init --timeout=300s
          # Migration might fail if DB schema already up-to-date; log and continue
          if ! kubectl -n "$NS" wait --for=condition=complete job/agent-migrate --timeout=300s; then
            echo '::warning::agent-migrate job did not complete successfully'
            kubectl -n "$NS" logs -l job-name=agent-migrate --tail=30 || true
          fi

      - name: Wait for deployments
        env:
          NS: ${{ github.event.inputs.namespace }}
        run: |
          set -euxo pipefail
          NS="${NS:-accounting-agent-staging}"
          kubectl -n "$NS" rollout status deployment/erpx-mock-api --timeout=300s
          if ! kubectl -n "$NS" rollout status deployment/agent-service --timeout=300s; then
            echo "::warning::agent-service rollout timed out (old replica pending termination). Continue to smoke checks."
            kubectl -n "$NS" get pods -l app=agent-service -o wide || true
          fi
          kubectl -n "$NS" rollout status deployment/agent-worker-io --timeout=300s || true
          kubectl -n "$NS" rollout status deployment/agent-worker-ocr --timeout=300s || true
          kubectl -n "$NS" rollout status deployment/agent-worker-export --timeout=300s || true
          kubectl -n "$NS" rollout status deployment/agent-scheduler --timeout=300s
          kubectl -n "$NS" rollout status deployment/ui --timeout=300s

      - name: Smoke (contract_obligation 5C, no UI click)
        continue-on-error: true
        env:
          NS: ${{ github.event.inputs.namespace }}
          AGENT_API_KEY: ${{ secrets.STAGING_AGENT_API_KEY }}
          MINIO_ACCESS_KEY: ${{ secrets.STAGING_MINIO_ACCESS_KEY }}
          MINIO_SECRET_KEY: ${{ secrets.STAGING_MINIO_SECRET_KEY }}
        run: |
          set -euo pipefail
          NS="${NS:-accounting-agent-staging}"

          kubectl -n "$NS" port-forward svc/agent-service 8000:8000 >/tmp/pf-agent.log 2>&1 &
          PF_AGENT=$!
          kubectl -n "$NS" port-forward svc/ui 8501:8501 >/tmp/pf-ui.log 2>&1 &
          PF_UI=$!
          kubectl -n "$NS" port-forward svc/minio 9000:9000 >/tmp/pf-minio.log 2>&1 &
          PF_MINIO=$!

          cleanup() {
            kill "$PF_AGENT" "$PF_UI" "$PF_MINIO" >/dev/null 2>&1 || true
          }
          trap cleanup EXIT

          export SMOKE_AGENT_BASE_URL="http://127.0.0.1:8000"
          export SMOKE_UI_BASE_URL="http://127.0.0.1:8501"
          export SMOKE_MINIO_ENDPOINT="http://127.0.0.1:9000"

          export AGENT_AUTH_MODE="api_key"
          export AGENT_API_KEY="$AGENT_API_KEY"
          export MINIO_ACCESS_KEY="$MINIO_ACCESS_KEY"
          export MINIO_SECRET_KEY="$MINIO_SECRET_KEY"

          python scripts/smoke_contract_obligation_demo.py --timeout 180

      - name: Benchmark smoke (5 cases)
        if: always()
        continue-on-error: true
        run: |
          set -euo pipefail
          ./scripts/benchmark/fetch_or_generate_dataset.sh --cases 5
          python -m pytest tests/benchmark/test_benchmark_smoke.py -q

      - name: Upload smoke + benchmark artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-and-benchmark-logs
          path: |
            /tmp/pf-*.log
            reports/benchmark/
          retention-days: 14
