name: deploy-prod

on:
  workflow_dispatch:
    inputs:
      overlay:
        description: "Kustomize overlay to deploy"
        required: true
        default: "prod-6nodes"
        type: choice
        options:
          - prod
          - prod-6nodes
      namespace:
        description: "Target namespace"
        required: true
        default: "accounting-agent"
      image_tag:
        description: "Image tag to deploy (empty => current commit SHA)"
        required: false
        default: ""

permissions:
  contents: read
  packages: read

concurrency:
  group: accounting-agent-prod
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: Setup kustomize
        run: |
          set -euo pipefail
          curl -sL "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.7.1/kustomize_v5.7.1_linux_amd64.tar.gz" \
            | tar xz -C /usr/local/bin
          kustomize version

      - name: Configure kubeconfig
        env:
          KUBECONFIG_B64: ${{ secrets.PROD_KUBECONFIG_B64 != '' && secrets.PROD_KUBECONFIG_B64 || secrets.STAGING_KUBECONFIG_B64 }}
        run: |
          set -euo pipefail
          if [ -z "${KUBECONFIG_B64:-}" ]; then
            echo "Missing secret: PROD_KUBECONFIG_B64 (or fallback STAGING_KUBECONFIG_B64)" >&2
            exit 1
          fi
          echo "${KUBECONFIG_B64}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> "$GITHUB_ENV"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Create/update image pull secret
        env:
          NS: ${{ inputs.namespace }}
          OVERLAY: ${{ inputs.overlay }}
          GHCR_USERNAME: ${{ github.actor }}
          GHCR_PASSWORD: ${{ github.token }}
        run: |
          set -euo pipefail
          OVERLAY_DIR="deploy/k8s/overlays/${OVERLAY}"
          kubectl apply -f "${OVERLAY_DIR}/namespace.yaml"
          kubectl -n "$NS" create secret docker-registry ghcr-pull \
            --docker-server=ghcr.io \
            --docker-username="$GHCR_USERNAME" \
            --docker-password="$GHCR_PASSWORD" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update k8s secrets (agent-llm)
        env:
          NS: ${{ inputs.namespace }}
          DO_AGENT_BASE_URL: ${{ secrets.PROD_DO_AGENT_BASE_URL != '' && secrets.PROD_DO_AGENT_BASE_URL || secrets.STAGING_DO_AGENT_BASE_URL }}
          DO_AGENT_API_KEY: ${{ secrets.PROD_DO_AGENT_API_KEY != '' && secrets.PROD_DO_AGENT_API_KEY || secrets.STAGING_DO_AGENT_API_KEY }}
          DO_AGENT_MODEL: ${{ secrets.PROD_DO_AGENT_MODEL != '' && secrets.PROD_DO_AGENT_MODEL || secrets.STAGING_DO_AGENT_MODEL }}
          OCR_CLOUD_BASE_URL: ${{ secrets.PROD_OCR_CLOUD_BASE_URL != '' && secrets.PROD_OCR_CLOUD_BASE_URL || secrets.STAGING_OCR_CLOUD_BASE_URL }}
          OCR_CLOUD_API_KEY: ${{ secrets.PROD_OCR_CLOUD_API_KEY != '' && secrets.PROD_OCR_CLOUD_API_KEY || secrets.STAGING_OCR_CLOUD_API_KEY }}
          OCR_CLOUD_MODEL: ${{ secrets.PROD_OCR_CLOUD_MODEL != '' && secrets.PROD_OCR_CLOUD_MODEL || secrets.STAGING_OCR_CLOUD_MODEL }}
          OCR_CLOUD_TIMEOUT_SECONDS: ${{ secrets.PROD_OCR_CLOUD_TIMEOUT_SECONDS != '' && secrets.PROD_OCR_CLOUD_TIMEOUT_SECONDS || secrets.STAGING_OCR_CLOUD_TIMEOUT_SECONDS }}
        run: |
          set -euo pipefail
          NS="${NS:-accounting-agent}"

          DO_AGENT_BASE_URL="${DO_AGENT_BASE_URL:-}"
          DO_AGENT_API_KEY="${DO_AGENT_API_KEY:-}"
          DO_AGENT_MODEL="${DO_AGENT_MODEL:-gpt-4.1-mini}"
          OCR_CLOUD_BASE_URL="${OCR_CLOUD_BASE_URL:-https://api.openai.com}"
          OCR_CLOUD_API_KEY="${OCR_CLOUD_API_KEY:-$DO_AGENT_API_KEY}"
          OCR_CLOUD_MODEL="${OCR_CLOUD_MODEL:-gpt-4.1-mini}"
          OCR_CLOUD_TIMEOUT_SECONDS="${OCR_CLOUD_TIMEOUT_SECONDS:-20}"

          if [ -z "${DO_AGENT_BASE_URL}" ] || [ -z "${DO_AGENT_API_KEY}" ]; then
            echo "Missing PROD_DO_AGENT_BASE_URL or PROD_DO_AGENT_API_KEY" >&2
            exit 1
          fi
          if [ -z "${OCR_CLOUD_API_KEY}" ]; then
            echo "Missing PROD_OCR_CLOUD_API_KEY (or fallback PROD_DO_AGENT_API_KEY)" >&2
            exit 1
          fi

          kubectl -n "$NS" create secret generic agent-llm \
            --from-literal=DO_AGENT_BASE_URL="${DO_AGENT_BASE_URL}" \
            --from-literal=DO_AGENT_API_KEY="${DO_AGENT_API_KEY}" \
            --from-literal=DO_AGENT_MODEL="${DO_AGENT_MODEL}" \
            --from-literal=OCR_CLOUD_BASE_URL="${OCR_CLOUD_BASE_URL}" \
            --from-literal=OCR_CLOUD_API_KEY="${OCR_CLOUD_API_KEY}" \
            --from-literal=OCR_CLOUD_MODEL="${OCR_CLOUD_MODEL}" \
            --from-literal=OCR_CLOUD_TIMEOUT_SECONDS="${OCR_CLOUD_TIMEOUT_SECONDS}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Delete old k8s jobs
        env:
          NS: ${{ inputs.namespace }}
        run: |
          set -euo pipefail
          kubectl -n "$NS" delete job --ignore-not-found=true agent-migrate
          kubectl -n "$NS" delete job --ignore-not-found=true minio-init

      - name: Patch image tag and apply manifests
        env:
          NS: ${{ inputs.namespace }}
          OVERLAY: ${{ inputs.overlay }}
          IMAGE_TAG: ${{ inputs.image_tag }}
        run: |
          set -euo pipefail
          OVERLAY_DIR="deploy/k8s/overlays/${OVERLAY}"
          TAG="${IMAGE_TAG:-}"
          if [ -z "$TAG" ]; then
            TAG="${GITHUB_SHA}"
          fi
          sed -i "s|newTag: latest|newTag: ${TAG}|g" "$OVERLAY_DIR/kustomization.yaml"
          sed -i "s|newTag: staging-latest|newTag: ${TAG}|g" "$OVERLAY_DIR/kustomization.yaml"
          kustomize build "$OVERLAY_DIR" | kubectl apply -f -
          # Avoid rollout deadlocks on 1-replica deployments in constrained clusters.
          for dep in erpx-mock-api agent-service agent-scheduler ui; do
            kubectl -n "$NS" patch deployment "$dep" --type merge -p '{"spec":{"strategy":{"type":"RollingUpdate","rollingUpdate":{"maxSurge":0,"maxUnavailable":1}}}}' || true
          done
          # Hard gate: jobs must complete successfully.
          kubectl -n "$NS" wait --for=condition=complete job/minio-init --timeout=600s
          if ! kubectl -n "$NS" wait --for=condition=complete job/agent-migrate --timeout=600s; then
            kubectl -n "$NS" logs -l job-name=agent-migrate --tail=200 || true
            echo "agent-migrate did not complete" >&2
            exit 1
          fi

          # Hard gate: all core deployments must fully roll out.
          for dep in erpx-mock-api agent-service agent-worker-io agent-worker-ocr agent-worker-export agent-scheduler ui; do
            kubectl -n "$NS" rollout status "deployment/${dep}" --timeout=600s
          done

          # Hard gate: no pending pods left and replicas ready/updated/available.
          PENDING="$(kubectl -n "$NS" get pods --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l | tr -d ' ')"
          if [ "${PENDING:-0}" -gt 0 ]; then
            kubectl -n "$NS" get pods -o wide || true
            echo "Deploy blocked: pending pods still exist" >&2
            exit 1
          fi
          for dep in erpx-mock-api agent-service agent-worker-io agent-worker-ocr agent-worker-export agent-scheduler ui; do
            desired="$(kubectl -n "$NS" get deployment "$dep" -o jsonpath='{.spec.replicas}')"
            ready="$(kubectl -n "$NS" get deployment "$dep" -o jsonpath='{.status.readyReplicas}')"
            updated="$(kubectl -n "$NS" get deployment "$dep" -o jsonpath='{.status.updatedReplicas}')"
            available="$(kubectl -n "$NS" get deployment "$dep" -o jsonpath='{.status.availableReplicas}')"
            ready="${ready:-0}"
            updated="${updated:-0}"
            available="${available:-0}"
            if [ "$ready" -lt "$desired" ] || [ "$updated" -lt "$desired" ] || [ "$available" -lt "$desired" ]; then
              kubectl -n "$NS" get deployment "$dep" -o wide || true
              echo "Deploy blocked: $dep not fully ready (desired=$desired ready=$ready updated=$updated available=$available)" >&2
              exit 1
            fi
          done

      - name: Smoke health check
        env:
          NS: ${{ inputs.namespace }}
          AGENT_API_KEY: ${{ secrets.PROD_AGENT_API_KEY != '' && secrets.PROD_AGENT_API_KEY || secrets.STAGING_AGENT_API_KEY }}
        run: |
          set -euo pipefail
          kubectl -n "$NS" port-forward svc/agent-service 8000:8000 >/tmp/pf-agent-prod.log 2>&1 &
          PF_AGENT=$!
          cleanup() {
            kill "$PF_AGENT" >/dev/null 2>&1 || true
          }
          trap cleanup EXIT
          ok=0
          for i in $(seq 1 20); do
            if [ -n "${AGENT_API_KEY:-}" ]; then
              if curl -fsS -H "X-API-Key: ${AGENT_API_KEY}" "http://127.0.0.1:8000/healthz" >/tmp/prod-healthz.json; then
                ok=1
                break
              fi
            else
              if curl -fsS "http://127.0.0.1:8000/healthz" >/tmp/prod-healthz.json; then
                ok=1
                break
              fi
            fi
            sleep 3
          done
          if [ "$ok" -ne 1 ]; then
            echo "healthz probe failed after retries" >&2
            exit 1
          fi
          cat /tmp/prod-healthz.json

      - name: Upload deploy logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-prod-logs
          path: |
            /tmp/pf-agent-prod.log
            /tmp/prod-healthz.json
          retention-days: 14
